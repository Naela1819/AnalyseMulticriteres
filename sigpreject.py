# -*- coding: utf-8 -*-
"""
/***************************************************************************
 newproject
                                 A QGIS plugin
 hello
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-02-09
        git sha              : $Format:%H$
        copyright            : (C) 2022 by nouha
        email                : nouh@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QVariant
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QFileDialog
from qgis._core import QgsVectorLayer, QgsProject, QgsFeature, QgsGeometry, QgsField
# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .sigpreject_dialog import newprojectDialog
import os.path


class newproject:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface

        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'newproject_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&sigproject')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None



    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('newproject', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/sigpreject/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u''),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True
        
    def openGeojson(self):
        infile = str(QFileDialog.getOpenFileName(None,'open logo file','',"Geojson (*.geojson)")[0])
        if infile:
            self.vlayer = QgsVectorLayer(infile,os.path.basename(infile), "ogr")
            QgsProject.instance().addMapLayer(self.vlayer)
            self.dlg.label_name.setText(infile)
        


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&sigproject'),
                action)
            self.iface.removeToolBarIcon(action)

    def getMatrice(self):
        #getting value
        m11 = float(self.dlg.m11.text())
        m12 = float(self.dlg.m12.text())
        m13 = float(self.dlg.m13.text())
        m21 = float(self.dlg.m21.text())
        m22 = float(self.dlg.m22.text())
        m23 = float(self.dlg.m23.text())
        m31 = float(self.dlg.m31.text())
        m32 = float(self.dlg.m32.text())
        m33 = float(self.dlg.m33.text())
        #somme des colonnes
        sum_c1 = m11+m21+m31
        sum_c2 = m12+m22+m32
        sum_c3 = m13+m23+m33
        #matrice normalisee
        m11_ = m11/sum_c1
        m21_ = m21/sum_c1
        m31_ = m31/sum_c1

        m12_ = m12/sum_c2
        m22_ = m22/sum_c2
        m32_ = m32/sum_c2

        m13_ = m13/sum_c3    
        m23_ = m23/sum_c3    
        m33_ = m33/sum_c3
        #somme ligne

        sum_l1 = m11_+m12_+m13_
        sum_l2 = m21_+m22_+m23_
        sum_l3 = m31_+m32_+m33_

        #new matrice
        m11 = m11*sum_l1
        m12 = m12*sum_l2
        m13 = m13*sum_l3

        m21 = m21*sum_l1
        m22 = m22*sum_l2
        m23 = m23*sum_l3

        m31 = m31*sum_l1
        m32 = m32*sum_l2
        m33 = m33*sum_l3

        #facteur
        fi_eco = m11+m12+m13
        fi_envi = m21+m22+m23
        fi_soc = m31+m32+m33

        return fi_eco,fi_envi,fi_soc



    def getPeriode1(self):
        fi_eco,fi_envi,fi_soc = self.getMatrice()
        p1_eco1 = float(self.dlg.p1_eco1.text())
        p1_envi1 = float(self.dlg.p1_envi1.text())
        p1_soc1 = float(self.dlg.p1_soc1.text())

        p2_eco1 = float(self.dlg.p2_eco1.text())
        p2_envi1 = float(self.dlg.p2_envi1.text())
        p2_soc1 = float(self.dlg.p2_soc1.text())

        p3_eco1 = float(self.dlg.p3_eco1.text())
        p3_envi1 = float(self.dlg.p3_envi1.text())
        p3_soc1 = float(self.dlg.p3_soc1.text())  

        p4_eco1 = float(self.dlg.p4_eco1.text())
        p4_envi1 = float(self.dlg.p4_envi1.text())
        p4_soc1 = float(self.dlg.p4_soc1.text())

        
        #calcul de composant economie
        c1_p1=(p1_eco1/400)*fi_eco
        c1_p2=(p2_eco1/500)*fi_eco
        c1_p3=(p3_eco1/1000)*fi_eco
        c1_p4=(p4_eco1/700)*fi_eco

        Ect1= c1_p1 +c1_p2 +c1_p3+c1_p4
        c1_vm = Ect1/4


        #calcul de composant environnement
        c2_p1=(p1_envi1/900)*fi_envi
        c2_p2=(p2_envi1/600)*fi_envi
        c2_p3=(p3_envi1/700)*fi_envi
        c2_p4=(p4_envi1/40)*fi_envi

        EV1= c2_p1 +c2_p2 +c2_p3+c2_p4
        c2_vm = EV1/4

        #calcul de composant societe
        c3_p1=(p1_soc1/68)*fi_soc
        c3_p2=(p2_soc1/60)*fi_soc
        c3_p3=(p3_soc1/50)*fi_soc
        c3_p4=(p4_soc1/50)*fi_soc

        ES1= c3_p1 +c3_p2 +c3_p3+c3_p4
        c3_vm = ES1/4


        return c1_vm,c2_vm,c3_vm

    def getPeriode2(self):
        fi_eco,fi_envi,fi_soc = self.getMatrice()
        p1_eco2 = float(self.dlg.p1_eco2.text())
        p1_envi2 = float(self.dlg.p1_envi2.text())
        p1_soc2 = float(self.dlg.p1_soc2 .text())

        p2_eco2 = float(self.dlg.p2_eco2.text())
        p2_envi2 = float(self.dlg.p2_envi2.text())
        p2_soc2 = float(self.dlg.p2_soc2 .text())

        p3_eco2 = float(self.dlg.p3_eco2.text())
        p3_envi2 = float(self.dlg.p3_envi2.text())
        p3_soc2 = float(self.dlg.p3_soc2.text())  

        p4_eco2 = float(self.dlg.p4_eco2.text())
        p4_envi2 = float(self.dlg.p4_envi2.text())
        p4_soc2 = float(self.dlg.p4_soc2 .text())  

        #calcul de composant economie
        c1_p11=(p1_eco2/400)*fi_eco
        c1_p22=(p2_eco2/500)*fi_eco
        c1_p33=(p3_eco2/1000)*fi_eco
        c1_p44=(p4_eco2/700)*fi_eco

        Ect12= c1_p11 +c1_p22 +c1_p33+c1_p44
        c1_vm2 = Ect12/4


        #calcul de composant environnement
        c2_p11=(p1_envi2/900)*fi_envi
        c2_p22=(p2_envi2/600)*fi_envi
        c2_p33=(p3_envi2/700)*fi_envi
        c2_p44=(p4_envi2/40)*fi_envi

        EV12= c2_p11 +c2_p22 +c2_p33+c2_p44
        c2_vm2 = EV12/4

        #calcul de composant societe
        c3_p11=(p1_soc2/68)*fi_soc
        c3_p22=(p2_soc2/60)*fi_soc
        c3_p33=(p3_soc2/50)*fi_soc
        c3_p44=(p4_soc2/50)*fi_soc

        ES12= c3_p11 +c3_p22 +c3_p33+c3_p44
        c3_vm2 = ES12/4


        return c1_vm2,c2_vm2,c3_vm2
        
    def getPeriode3(self):
        fi_eco,fi_envi,fi_soc = self.getMatrice()
        p1_eco3 = float(self.dlg.p1_eco3.text())
        p1_envi3 = float(self.dlg.p1_envi3.text())
        p1_soc3 = float(self.dlg.p1_soc3.text())

        p2_eco3 = float(self.dlg.p2_eco3.text())
        p2_envi3 = float(self.dlg.p2_envi3.text())
        p2_soc3 = float(self.dlg.p2_soc3.text())

        p3_eco3 = float(self.dlg.p3_eco2.text())
        p3_envi3 = float(self.dlg.p3_envi2.text())
        p3_soc3 = float(self.dlg.p3_soc2.text())  

        p4_eco3 = float(self.dlg.p4_eco3.text())
        p4_envi3 = float(self.dlg.p4_envi3.text())
        p4_soc3 = float(self.dlg.p4_soc3.text()) 

        
        #calcul de composant economie
        c1_p111=(p1_eco3/400)*fi_eco
        c1_p222=(p2_eco3/500)*fi_eco
        c1_p333=(p3_eco3/1000)*fi_eco
        c1_p444=(p4_eco3/700)*fi_eco

        Ect13= c1_p111 +c1_p222 +c1_p333+c1_p444
        c1_vm3 = Ect13/4


        #calcul de composant environnement
        c2_p111=(p1_envi3/900)*fi_envi
        c2_p222=(p2_envi3/600)*fi_envi
        c2_p333=(p3_envi3/700)*fi_envi
        c2_p444=(p4_envi3/40)*fi_envi

        EV13= c2_p111 +c2_p222 +c2_p333+c2_p444
        c2_vm3 = EV13/4

        #calcul de composant societe
        c3_p111=(p1_soc3/68)*fi_soc
        c3_p222=(p2_soc3/60)*fi_soc
        c3_p333=(p3_soc3/50)*fi_soc
        c3_p444=(p4_soc3/50)*fi_soc

        ES13= c3_p111 +c3_p222 +c3_p333+c3_p444
        c3_vm3 = ES13/4


        return c1_vm3,c2_vm3,c3_vm3



    def calcul_rst(self):

        
        a,b,c = self.getPeriode1()
        d,e,f = self.getPeriode2()
        i,j,k = self.getPeriode3()

        
        self.dlg.rst_c1.setText(str(round(a,2)))
        self.dlg.rst_c2.setText(str(round(b,2)))
        self.dlg.rst_c3.setText(str(round(c,2)))
        self.dlg.rst2_c1.setText(str(round(d,2)))
        self.dlg.rst2_c2.setText(str(round(e,2)))
        self.dlg.rst2_c3.setText(str(round(f,2)))
        self.dlg.rst3_c1.setText(str(round(i,2)))
        self.dlg.rst3_c2.setText(str(round(j,2)))
        self.dlg.rst3_c3.setText(str(round(k,2)))

        
        seuil_eco = float(self.dlg.seuileco.text())
        seuil_envi = float(self.dlg.seuilenvi.text())
        seuil_soc = float(self.dlg.seuilsoc.text())

        self.decisp1 = []
        self.decisp2 = []
        self.decisp3 = []
        self.decisfinalp1 = []
        self.decisfinalp2 = []
        self.decisfinalp3 = []
        self.decisfinal = []
        

        if (a<(seuil_eco*4)):
            self.dlg.rst_c22.setText("Non durable")
            self.decisp1.append("Non durable")
        else :
            self.dlg.rst_c22.setText("durable")
            self.decisp1.append("Durable")
        
        if (d<(seuil_eco*4)):
            self.dlg.rst_c2_5.setText("Non durable")
            self.decisp2.append("Non durable")
        else :
            self.dlg.rst_c2_5.setText("durable")
            self.decisp2.append("Durable")

        if (i<(seuil_eco*4)):
            self.dlg.rst_c2_6.setText("Non durable")
            self.decisp3.append("Non durable")
        else :
            self.dlg.rst_c2_6.setText("durable")
            self.decisp3.append("Durable")


        if (b<(seuil_envi*4)):
            self.dlg.rst_c2_10.setText("Non durable")
            self.decisp1.append("Non durable")
        else :
            self.dlg.rst_c2_10.setText("durable")
            self.decisp1.append("durable")
        if (e<(seuil_envi*4)):
            self.dlg.rst_c2_18.setText("Non durable")
            self.decisp2.append("Non durable")
        else :
            self.dlg.rst_c2_18.setText("durable")
            self.decisp2.append("durable")
        if (j<(seuil_envi*4)):
            self.dlg.rst_c2_20.setText("Non durable")
            self.decisp3.append("Non durable")
        else :
            self.dlg.rst_c2_20.setText("durable")
            self.decisp3.append(" durable")

        if (c<(seuil_soc*4)):
            self.dlg.rst_c2_11.setText("Non durable")
            self.decisp1.append("Non durable")
        else :
            self.dlg.rst_c2_11.setText("durable")
            self.decisp1.append("durable")
        if (f<(seuil_soc*4)):
            self.dlg.rst_c2_19.setText("Non durable")
            self.decisp2.append("Non durable")
        else :
            self.dlg.rst_c2_19.setText("durable")
            self.decisp2.append("durable")
        if (k<(seuil_soc*4)):
            self.dlg.rst_c2_21.setText("Non durable")
            self.decisp3.append("Non durable")
        else :
            self.dlg.rst_c2_21.setText("durable")
            self.decisp3.append("durable")


        if ((self.dlg.rst_c22.toPlainText() == "Non durable" and self.dlg.rst_c2_10.toPlainText() == "Non durable") or
         (self.dlg.rst_c22.toPlainText() == "Non durable" and self.dlg.rst_c2_11.toPlainText() == "Non durable") or
         (self.dlg.rst_c2_10.toPlainText() == "Non durable" and self.dlg.rst_c2_11.toPlainText() == "Non durable") or
         (self.dlg.rst_c2_10.toPlainText() == "Non durable" and self.dlg.rst_c2_11.toPlainText() == "Non durable" and
         self.dlg.rst_c22.toPlainText() == "Non durable")
         ) :
            self.decisfinalp1.append("Non durable")
            self.decisfinal.append(0)

        else :
            self.decisfinalp1.append("Durable")
            self.decisfinal.append(1)

        if ((self.dlg.rst_c2_5.toPlainText() == "Non durable" and self.dlg.rst_c2_18.toPlainText() == "Non durable") or
         (self.dlg.rst_c2_5.toPlainText() == "Non durable" and self.dlg.rst_c2_19.toPlainText() == "Non durable") or
         (self.dlg.rst_c2_18.toPlainText()== "Non durable" and self.dlg.rst_c2_19.toPlainText() == "Non durable") or
         (self.dlg.rst_c2_18.toPlainText() == "Non durable" and self.dlg.rst_c2_19.toPlainText() == "Non durable" 
         and self.dlg.rst_c2_5.toPlainText() == "Non durable")
         ) :
            self.decisfinalp2.append("Non durable")
            self.decisfinal.append(0)

        else :
            self.decisfinalp2.append("Durable")
            self.decisfinal.append(1)

        if ((self.dlg.rst_c2_6.toPlainText() == "Non durable" and self.dlg.rst_c2_20.toPlainText() == "Non durable") or
         (self.dlg.rst_c2_6.toPlainText() == "Non durable" and self.dlg.rst_c2_21.toPlainText() == "Non durable") or
         (self.dlg.rst_c2_20.toPlainText() == "Non durable" and self.dlg.rst_c2_21.toPlainText() == "Non durable") or
         
         (self.dlg.rst_c2_18.toPlainText() == "Non durable" and self.dlg.rst_c2_19.toPlainText() == "Non durable" and
         self.dlg.rst_c2_6.toPlainText() == "Non durable")
         ) :
            self.decisfinalp3.append("Non durable")
            self.decisfinal.append(0)

        else :
            self.decisfinalp3.append("Durable")
            self.decisfinal.append(1)

    def creationlayr(self, layer, liste, nom):
        feats = [feat for feat in layer.getFeatures()]

        newLayer = QgsVectorLayer("Polygon", nom, "memory")

        mem_layer_data = newLayer.dataProvider()
        attr = layer.dataProvider().fields().toList()
        mem_layer_data.addAttributes(attr)
        newLayer.updateFields()
        mem_layer_data.addFeatures(feats)

        pr = newLayer.dataProvider()  
        i = 0
        for i in range(4):
            pr.addAttributes([QgsField(liste[i], QVariant.String)])  
        feature = QgsFeature()

        li = [None] * len(attr)
        if nom == "periode 1":
            for decis in self.decisp1:
                li.append(decis)
            for decis in self.decisfinalp1:
                li.append(decis)
        elif nom == "periode 2":
            for decis in self.decisp2:
                li.append(decis)
            for decis in self.decisfinalp2:
                li.append(decis)
        else:
            for decis in self.decisp3:
                li.append(decis)
            for decis in self.decisfinalp3:
                li.append(decis)
        
        


        feature.setAttributes(li)

        newLayer.updateFields()
        pr.addFeatures([feature])
        # mem_layer_data.addFeatures(feature)
        QgsProject.instance().addMapLayer(newLayer)
               
        
    def page(self,nbr):
        
        if nbr == 6:
            self.dlg.stackedWidget.setCurrentWidget(self.dlg.page_6)
            self.calcul_rst()
            resultList = ["Economique", "Environmentale", "Societale","Finale"]
            self.creationlayr(self.vlayer.clone(),resultList,"periode 1")
            self.creationlayr(self.vlayer.clone(),resultList,"periode 2")
            self.creationlayr(self.vlayer.clone(),resultList,"periode 3")
            #Creating layer for final decision
            newLayer = QgsVectorLayer("Polygon", "Zone Decision", "memory")
            pr = newLayer.dataProvider()
            pr.addAttributes([QgsField("Decision", QVariant.String)])
            f = QgsFeature()
            #Determining the decision

            self.sumDes = self.decisfinal[0]+self.decisfinal[1]+self.decisfinal[2]
            if(self.sumDes == 0 or self.sumDes == 1):
                f.setAttributes(["Non Durable"])
                newLayer.updateFields()
                pr.addFeature(f)
            else:
                f.setAttributes(["Durable"])
                newLayer.updateFields()
                pr.addFeature(f)
            QgsProject.instance().addMapLayer(newLayer)
                

        else:
            self.dlg.stackedWidget.setCurrentWidget(self.dlg.page)








    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = newprojectDialog()

        self.dlg.menu_bt.clicked.connect(lambda: self.dlg.stackedWidget.setCurrentWidget(self.dlg.page_2))
        
        self.dlg.next.clicked.connect(self.openGeojson)
        self.dlg.next_2.clicked.connect(lambda: self.dlg.stackedWidget.setCurrentWidget(self.dlg.page_3))
        self.dlg.next_3.clicked.connect(lambda: self.dlg.stackedWidget.setCurrentWidget(self.dlg.page_4))
        self.dlg.next_4.clicked.connect(lambda: self.dlg.stackedWidget.setCurrentWidget(self.dlg.page_5))

        self.dlg.calcul1.clicked.connect(lambda: self.page(6))

        self.dlg.back.clicked.connect(lambda: self.dlg.stackedWidget.setCurrentWidget(self.dlg.page_2))
        self.dlg.back_2.clicked.connect(lambda: self.dlg.stackedWidget.setCurrentWidget(self.dlg.page_3))
        self.dlg.back_3.clicked.connect(lambda: self.dlg.stackedWidget.setCurrentWidget(self.dlg.page_4))

        self.dlg.quit_bt.clicked.connect(lambda: self.dlg.close())




        



        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass
